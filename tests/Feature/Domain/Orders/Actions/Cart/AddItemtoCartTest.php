<?php

namespace Tests\Feature\Domain\Orders\Actions\Cart;

use App\Api\Orders\Exceptions\Cart\ItemQtyAdjustedWarning;
use Domain\CustomForms\Models\CustomForm;
use Domain\CustomForms\Models\FormSectionField;
use Domain\Orders\Actions\Cart\Item\AddItemToCartFromDto;
use Domain\Orders\Dtos\CartItemDto;
use Domain\Orders\Dtos\CustomFormFieldValueData;
use Domain\Orders\Dtos\OptionCustomValuesData;
use Domain\Orders\Models\Carts\Cart;
use Domain\Orders\Models\Carts\CartItems\CartItem;
use Domain\Orders\Models\Carts\CartItems\CartItemCustomField;
use Domain\Orders\Models\Carts\CartItems\CartItemOption;
use Domain\Products\Enums\OrderingConditionTypes;
use Domain\Products\Enums\ProductOptionCustomTypes;
use Domain\Products\Exceptions\FailedOrderRuleCheck;
use Domain\Products\Exceptions\NotAvailableToOrder;
use Domain\Products\Exceptions\NotPublishedToSite;
use Domain\Products\Models\OrderingRules\OrderingCondition;
use Domain\Products\Models\Product\Option\ProductOption;
use Domain\Products\Models\Product\Option\ProductOptionCustom;
use Domain\Products\Models\Product\Option\ProductOptionValue;
use Domain\Products\Models\Product\Pricing\PricingRule;
use Domain\Products\Models\Product\Pricing\PricingRuleLevel;
use Domain\Products\Models\Product\Product;
use Domain\Products\Models\Product\ProductAccessory;
use Domain\Products\Models\Product\ProductAvailability;
use Domain\Products\Models\Product\ProductPricing;
use Domain\Sites\Models\Site;
use Domain\Sites\Models\SiteSettings;
use Support\Enums\AmountAdjustmentTypes;
use Tests\TestCase;

class AddItemtoCartTest extends TestCase
{
    private Product $product;
    private Site $site;
    private Cart $cart;
    private CartItemDto $dto;
    private ProductPricing $pricing;

    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->site = Site::firstOrFactory();

        SiteSettings::factory()
            ->for($this->site)
            ->create([
                'cart_allowavailability' => ProductAvailability::factory(3)
                    ->create()
                    ->pluck('id')
                    ->toArray()
            ]);

        $this->cart = Cart::factory()->create();

        $this->product = Product::firstOrFactory([
            'combined_stock_qty' => 3
        ]);

        $this->dto = CartItemDto::from([
            'site' => $this->site,
            'product' => $this->product,
            'orderQty' => 2,
            'availableStockQty' => 3,
            'pricing' => $this->pricing = ProductPricing::firstOrFactory([
                'site_id' => $this->site->id
            ]),
            'availability' => ProductAvailability::firstOrFactory()
        ]);

//        ProductDetail::factory()->create();
//        ProductAttribute::factory()->create();
//        $priceLevel = PricingRuleLevel::factory()->create();
//        $rule = OrderingRule::factory()->create();
//        ProductPricing::factory()->create([
//            'pricing_rule_id' => $priceLevel->rule_id,
//            'ordering_rule_id' => $rule->id
//        ]);
    }

    /** @test */
    public function can_add_simple_item()
    {
        $this->assertDatabaseCount(CartItem::Table(), 0);

        $added = AddItemToCartFromDto::run(
            $this->cart,
            $this->dto,
        );

        $this->sharedAssertions($added);
    }

    /** @test */
    public function can_add_child_product()
    {
        $parentProduct = Product::factory()->create();

        $this->product->update(['parent_product' => $parentProduct->id]);
        $this->dto->parentProduct($parentProduct);

        $this->assertDatabaseCount(CartItem::Table(), 0);

        $added = AddItemToCartFromDto::run(
            $this->cart,
            $this->dto,
        );

        $this->sharedAssertions($added);
    }

    /** @test */
    public function will_adjust_if_max_qty_available_limit()
    {
        $this->assertDatabaseCount(CartItem::Table(), 0);

        $this->site->settings()->update([
            'cart_orderonlyavailableqty' => true
        ]);
        $this->dto->orderQty = 4;

        $added = AddItemToCartFromDto::run(
            $this->cart,
            $this->dto,
        );

        $this->assertCount(1, $added->exceptions());

        $this->sharedAssertions($added, 3);
    }

    /** @test */
    public function will_adjust_price_per_pricing_rule()
    {
        PricingRuleLevel::factory()
            ->for(
                $rule = PricingRule::firstOrFactory(),
                'rule'
            )
            ->create([
                'amount_type' => AmountAdjustmentTypes::PERCENTAGE,
                'amount' => 10,
                'min_qty' => 2
            ]);

        $this->pricing->update([
            'price_reg' => 4000,
            'onsale' => false,
            'pricing_rule_id' => $rule->id
        ]);
        $this->dto->pricing = $this->pricing;

        $this->assertDatabaseCount(CartItem::Table(), 0);

        $added = AddItemToCartFromDto::run(
            $this->cart,
            $this->dto,
        );

        $this->assertEquals(3600.00, $added->cartItem->price_reg);
        $this->sharedAssertions($added, 2);
    }

    /** @test */
    public function will_save_accessories()
    {
        $productAccessories = ProductAccessory::factory(2)
            ->for($this->product)
            ->create([
                'show_as_option' => true,
                'required' => true
            ]);

        $this->dto->accessories(
            $productAccessories
                ->each(
                    fn(ProductAccessory $productAccessory) => ProductPricing::factory()
                        ->for($this->site)
                        ->create([
                            'product_id' => $productAccessory->accessory_id
                        ])
                )
                ->map(
                    fn(ProductAccessory $productAccessory) => [
                        'accessory_id' => $productAccessory->accessory_id,
                        'qty' => 1,
                        'options' => []
                    ]
                )->toArray()
        );

        $added = AddItemToCartFromDto::run(
            $this->cart,
            $this->dto,
        );

        $this->assertCount(2, $added->cartItem->childrenItems);
        $this->sharedAssertions($added, 2, 3);
    }

    /** @test */
    public function will_save_custom_field_values()
    {
        $formSectionField = FormSectionField::factory()->create();

        $this->dto->customFields([
            (new CustomFormFieldValueData(
                CustomForm::first()->id,
                $formSectionField->section_id,
                $formSectionField->field_id,
                fake()->word
            ))->toArray()
        ]);

        $added = AddItemToCartFromDto::run(
            $this->cart,
            $this->dto,
        );

        $this->assertCount(1, $added->cartItem->customFields);
        $this->assertDatabaseCount(CartItemCustomField::Table(), 1);
        $this->sharedAssertions($added);
    }

    /** @test */
    public function will_save_option_custom_values()
    {
        $parent = ProductPricing::factory()
            ->for(Product::factory()->create(['parent_product' => null]))
            ->create();

        $this->product->update(['parent_product' => $parent->product->id]);

        ProductOptionCustom::factory()
            ->for($optionValue = ProductOptionValue::factory()
                ->for(
                    ProductOption::factory()
                        ->for($parent->product)->create(),
                    'option'
                )
                ->create(),
                'optionValue'
            )
            ->create(['custom_type' => ProductOptionCustomTypes::TEXT]);

        $this->dto->optionValues([
            (new OptionCustomValuesData(
                $optionValue->id,
                'custom text dummy value'
            ))->toArray()
        ]);

        $added = AddItemToCartFromDto::run(
            $this->cart,
            $this->dto,
        );

        $this->assertCount(1, $added->cartItem->optionValues);
        $this->assertDatabaseCount(CartItemOption::Table(), 1);
        $this->sharedAssertions($added);
    }

    /** @test */
    public function will_find_and_update_if_item_already_in_cart()
    {
        $this->withoutExceptionHandling();
        $this->assertDatabaseCount(CartItem::Table(), 0);

        $added = AddItemToCartFromDto::run(
            $this->cart,
            $this->dto,
        );

        $this->sharedAssertions($added);

        $this->dto->orderQty = 1;

        $added = AddItemToCartFromDto::run(
            $this->cart,
            $this->dto,
        );

        $this->assertTrue($added->updatedExistingItem);
        $this->sharedAssertions($added, 3);
    }

    /** @test */
    public function will_adjust_for_max_qty()
    {
        $this->pricing->update(['max_qty' => 1]);

        /** @var AddItemToCartFromDto $added */
        $added = AddItemToCartFromDto::run(
            $this->cart,
            $this->dto,
        );

        $this->assertCount(1, $added->exceptions()->filter(
            fn(\Throwable $exception) => $exception instanceof ItemQtyAdjustedWarning
        ));

        $this->sharedAssertions($added, 1);
    }

    /** @test */
    public function will_adjust_for_min_qty()
    {
        $this->pricing->update(['min_qty' => 2]);

        $this->dto->orderQty = 1;

        /** @var AddItemToCartFromDto $added */
        $added = AddItemToCartFromDto::run(
            $this->cart,
            $this->dto,
        );

        $this->assertCount(1, $added->exceptions()->filter(
            fn(\Throwable $exception) => $exception instanceof ItemQtyAdjustedWarning
        ));

        $this->sharedAssertions($added, 2);
    }

    /** @test */
    public function will_fail_if_product_not_published_to_site()
    {
        $this->dto->pricing->update(['status' => false]);

        $this->assertDatabaseCount(CartItem::Table(), 0);

        try {
            $this->expectException(NotPublishedToSite::class);

            $added = AddItemToCartFromDto::run(
                $this->cart,
                $this->dto,
            );
        } finally {
            $this->assertDatabaseCount(CartItem::Table(), 0);
        }
    }

    /** @test */
    public function will_fail_if_not_allowed_to_order_availability()
    {
        $availability = ProductAvailability::factory()->create();
        $this->product->update([
            'inventoried' => false,
            'default_outofstockstatus_id' => $availability->id
        ]);

        $this->dto->availability = $availability;

        $this->expectException(NotAvailableToOrder::class);

        AddItemToCartFromDto::run(
            $this->cart,
            $this->dto,
        );
    }

    /** @test */
    public function will_fail_if_fails_ordering_rule()
    {
        $this->pricing->update([
            'ordering_rule_id' => OrderingCondition::factory()
                ->create([
                    'type' => OrderingConditionTypes::REQUIRED_ACCOUNT_TYPE
                ])->rule_id
        ]);

        $this->expectException(FailedOrderRuleCheck::class);

        AddItemToCartFromDto::run(
            $this->cart,
            $this->dto,
        );
    }

    /** @todo */
    public function will_fail_main_add_if_sub_items_fail()
    {
        //i.e. won't commit db transaction if sub items fail

    }

    protected function sharedAssertions(
        AddItemToCartFromDto $added,
        int                  $expectedQty = 2,
        int                  $cartItemCount = 1
    ): void
    {
        $this->assertInstanceOf(CartItem::class, $added->cartItem);
        $this->assertDatabaseCount(CartItem::Table(), $cartItemCount);

        $items = $this->cart->refresh()->items;
        $this->assertCount($cartItemCount, $items);
        $item = $items->first();

        $this->assertCount(
            2,
            array_intersect([
                'qty' => $expectedQty,
                'product_id' => $this->product->id
            ], $item->toArray())
        );
        $this->assertGreaterThan(0, $this->cart->subTotal());
    }
}
